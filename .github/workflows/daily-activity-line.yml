name: Daily Activity Notification

on:
  schedule:
    # æ¯æ—¥ 00:10 JSTï¼ˆ15:10 UTCï¼‰ã«é€šçŸ¥
    - cron: "10 15 * * *"
  workflow_dispatch:

jobs:
  notify:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Collect daily activity
        id: stats
        shell: bash
        env:
          TARGET_TZ: Asia/Tokyo
        run: |
          target_date=$(TZ="${TARGET_TZ}" date -d 'yesterday' +%Y-%m-%d)
          since="${target_date}T00:00:00+09:00"
          until="${target_date}T23:59:59+09:00"

          commit_count=$(git rev-list --count --no-merges --since="$since" --until="$until" HEAD || echo 0)

          declare -A seen_files
          lines_added=0
          lines_deleted=0

          while IFS=$'\t' read -r added deleted file; do
            if [[ -z "$file" || "$file" == "-" ]]; then
              continue
            fi
            # è¿½åŠ ãƒ»å‰Šé™¤è¡Œæ•°ãŒ "-" ã®ã‚±ãƒ¼ã‚¹ã¯å·¨å¤§ãƒ•ã‚¡ã‚¤ãƒ«ãªã®ã§é›†è¨ˆå¯¾è±¡å¤–
            if [[ "$added" != "-" ]]; then
              lines_added=$((lines_added + added))
            fi
            if [[ "$deleted" != "-" ]]; then
              lines_deleted=$((lines_deleted + deleted))
            fi
            seen_files["$file"]=1
          done < <(git log --no-merges --since="$since" --until="$until" --numstat --pretty=tformat:)

          files_changed=${#seen_files[@]}
          lines_changed=$((lines_added + lines_deleted))

          if [[ "$commit_count" -eq 0 ]]; then
            color_hex="#ebedf0"
            color_level="ãƒ¬ãƒ™ãƒ«0ï¼ˆè²¢çŒ®ãªã—ï¼‰"
          elif [[ "$commit_count" -le 2 ]]; then
            color_hex="#9be9a8"
            color_level="ãƒ¬ãƒ™ãƒ«1ï¼ˆå°‘ã—è²¢çŒ®ï¼‰"
          elif [[ "$commit_count" -le 4 ]]; then
            color_hex="#40c463"
            color_level="ãƒ¬ãƒ™ãƒ«2ï¼ˆé©åº¦ã«è²¢çŒ®ï¼‰"
          elif [[ "$commit_count" -le 6 ]]; then
            color_hex="#30a14e"
            color_level="ãƒ¬ãƒ™ãƒ«3ï¼ˆã‹ãªã‚Šè²¢çŒ®ï¼‰"
          else
            color_hex="#216e39"
            color_level="ãƒ¬ãƒ™ãƒ«4ï¼ˆã¨ã¦ã‚‚æ´»ç™ºï¼‰"
          fi

          {
            echo "target_date=$target_date"
            echo "commit_count=$commit_count"
            echo "files_changed=$files_changed"
            echo "lines_added=$lines_added"
            echo "lines_deleted=$lines_deleted"
            echo "lines_changed=$lines_changed"
            echo "color_hex=$color_hex"
            echo "color_level=$color_level"
          } >> "$GITHUB_OUTPUT"

      - name: Send LINE message via Messaging API
        env:
          LINE_CHANNEL_ACCESS_TOKEN: ${{ secrets.LINE_CHANNEL_ACCESS_TOKEN }}
          LINE_TARGET_ID: ${{ secrets.LINE_TARGET_ID }}
          TARGET_DATE: ${{ steps.stats.outputs.target_date }}
          COMMIT_COUNT: ${{ steps.stats.outputs.commit_count }}
          FILES_CHANGED: ${{ steps.stats.outputs.files_changed }}
          LINES_CHANGED: ${{ steps.stats.outputs.lines_changed }}
          LINES_ADDED: ${{ steps.stats.outputs.lines_added }}
          LINES_DELETED: ${{ steps.stats.outputs.lines_deleted }}
          COLOR_LEVEL: ${{ steps.stats.outputs.color_level }}
        run: |
          if [[ -z "${LINE_CHANNEL_ACCESS_TOKEN}" ]]; then
            echo "LINE Messaging API ã®ãƒãƒ£ãƒãƒ«ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ (LINE_CHANNEL_ACCESS_TOKEN)ã€‚" >&2
            exit 1
          fi

          if [[ -z "${LINE_TARGET_ID}" ]]; then
            echo "é€ä¿¡å…ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ / ãƒ«ãƒ¼ãƒ  ID ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ (LINE_TARGET_ID)ã€‚" >&2
            exit 1
          fi

          printf -v message 'ğŸ“Š %s ã®æ´»å‹•ã‚µãƒãƒªãƒ¼\n- ã‚³ãƒŸãƒƒãƒˆæ•°: %s\n- å¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«æ•°: %s\n- å¤‰æ›´è¡Œæ•° (Â±): %s\n- å†…è¨³: è¿½åŠ  %s è¡Œ / å‰Šé™¤ %s è¡Œ\n- è²¢çŒ®ãƒ¬ãƒ™ãƒ«: %s' \
            "${TARGET_DATE}" "${COMMIT_COUNT}" "${FILES_CHANGED}" "${LINES_CHANGED}" "${LINES_ADDED}" "${LINES_DELETED}" "${COLOR_LEVEL}"

          # Support single ID or multiple IDs (comma/newline/space separated)
          # Normalize separators to newlines, drop empty lines
          ids_clean=$(printf '%s' "${LINE_TARGET_ID}" | tr ',' '\n' | tr -s ' ' '\n' | tr '\r' '\n' | sed '/^\s*$/d')

          # Build JSON array of recipients using jq. This produces compact JSON like ["Uxxxx","Uyyyy"]
          to_json=$(printf '%s\n' "${ids_clean}" | jq -R . | jq -s -c .)

          # Build payload: use the same shape for push (single) and multicast (multiple)
          payload=$(jq -n --argjson to "${to_json}" --arg text "${message}" '{to: $to, messages: [{type: "text", text: $text}]}')

          # Choose endpoint: push supports a single recipient string, multicast supports arrays of recipients
          recipient_count=$(printf '%s\n' "${ids_clean}" | wc -l | tr -d ' ')

          if [[ "${recipient_count}" -gt 1 ]]; then
            endpoint="https://api.line.me/v2/bot/message/multicast"
          else
            # For push the API expects 'to' to be a string, not an array. Extract single id value.
            single_to=$(printf '%s\n' "${ids_clean}" | head -n1)
            payload=$(jq -n --arg to "${single_to}" --arg text "${message}" '{to: $to, messages: [{type: "text", text: $text}]}')
            endpoint="https://api.line.me/v2/bot/message/push"
          fi

          curl -sS -X POST \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${LINE_CHANNEL_ACCESS_TOKEN}" \
            -d "${payload}" \
            "${endpoint}"
